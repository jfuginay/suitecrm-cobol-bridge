import React, { useState } from 'react';
import { Card, Button, Space, Select, Tabs, Typography, message, Divider } from 'antd';
import { DownloadOutlined, CopyOutlined, FileTextOutlined, CodeOutlined } from '@ant-design/icons';
import CodeMirror from '@uiw/react-codemirror';
import { saveAs } from 'file-saver';

const { TabPane } = Tabs;
const { Title, Paragraph, Text } = Typography;
const { Option } = Select;

const CobolExporter = ({ rules, flowElements }) => {
  const [exportFormat, setExportFormat] = useState('cobol');
  const [indentSize, setIndentSize] = useState(4);
  
  const generateCobolCode = (rules) => {
    let code = '';
    const indent = ' '.repeat(indentSize);
    
    // Add header comments
    code += `      *================================================================\n`;
    code += `      * Business Rules Generated by COBOL Rule Editor\n`;
    code += `      * Generated on: ${new Date().toLocaleString()}\n`;
    code += `      * Total Rules: ${rules.length}\n`;
    code += `      *================================================================\n\n`;
    
    // Generate code for each rule
    rules.forEach((rule, index) => {
      code += `      *----------------------------------------------------------------\n`;
      code += `      * Rule ${index + 1}: ${rule.type.toUpperCase()} Statement\n`;
      code += `      *----------------------------------------------------------------\n`;
      
      if (rule.type === 'decision') {
        code += generateDecisionCode(rule, indent);
      } else if (rule.type === 'evaluate') {
        code += generateEvaluateCode(rule, indent);
      }
      
      code += '\n';
    });
    
    return code;
  };
  
  const generateDecisionCode = (rule, indent) => {
    let code = `${indent}IF ${formatConditionToCobol(rule.condition)}\n`;
    
    // True branch
    if (rule.trueBranch && rule.trueBranch.length > 0) {
      rule.trueBranch.forEach(action => {
        code += `${indent}   ${formatActionToCobol(action)}\n`;
      });
    }
    
    // False branch
    if (rule.falseBranch && rule.falseBranch.length > 0) {
      code += `${indent}ELSE\n`;
      rule.falseBranch.forEach(action => {
        code += `${indent}   ${formatActionToCobol(action)}\n`;
      });
    }
    
    code += `${indent}END-IF`;
    
    return code;
  };
  
  const generateEvaluateCode = (rule, indent) => {
    let code = `${indent}EVALUATE ${rule.subject}\n`;
    
    rule.cases.forEach(caseItem => {
      code += `${indent}   WHEN ${caseItem.condition}\n`;
      caseItem.actions.forEach(action => {
        code += `${indent}      ${formatActionToCobol(action)}\n`;
      });
    });
    
    code += `${indent}END-EVALUATE`;
    
    return code;
  };
  
  const formatConditionToCobol = (condition) => {
    if (!condition) return 'TRUE';
    
    switch (condition.type) {
      case 'comparison':
        return `${condition.field} ${condition.operator} "${condition.value}"`;
        
      case 'compound':
        return condition.conditions
          .map(c => formatConditionToCobol(c))
          .join(` ${condition.operator} `);
          
      case 'function':
        return `${condition.function}(${condition.argument})`;
        
      case 'boolean':
        return condition.field;
        
      default:
        return 'TRUE';
    }
  };
  
  const formatActionToCobol = (action) => {
    switch (action.type) {
      case 'assignment':
        return `MOVE ${action.source} TO ${action.target}`;
        
      case 'computation':
        return `COMPUTE ${action.target} = ${action.expression}`;
        
      case 'perform':
        return `PERFORM ${action.procedure}`;
        
      case 'display':
        return `DISPLAY "${action.message}"`;
        
      default:
        return action.statement || '* Unknown action';
    }
  };
  
  const generateProcedureDivision = (rules) => {
    const indent = ' '.repeat(indentSize);
    let code = `       PROCEDURE DIVISION.\n`;
    code += `       MAIN-PROCEDURE.\n`;
    code += `${indent}*> Apply business rules\n`;
    
    rules.forEach((rule, index) => {
      code += `${indent}PERFORM APPLY-RULE-${index + 1}\n`;
    });
    
    code += `${indent}STOP RUN.\n\n`;
    
    // Generate individual rule procedures
    rules.forEach((rule, index) => {
      code += `       APPLY-RULE-${index + 1}.\n`;
      if (rule.type === 'decision') {
        code += generateDecisionCode(rule, indent);
      } else if (rule.type === 'evaluate') {
        code += generateEvaluateCode(rule, indent);
      }
      code += `.\n\n`;
    });
    
    return code;
  };
  
  const generateDocumentation = (rules) => {
    let doc = `# Business Rules Documentation\n\n`;
    doc += `Generated on: ${new Date().toLocaleString()}\n\n`;
    doc += `## Overview\n\n`;
    doc += `This document describes ${rules.length} business rule${rules.length !== 1 ? 's' : ''} `;
    doc += `extracted from COBOL programs.\n\n`;
    
    rules.forEach((rule, index) => {
      doc += `## Rule ${index + 1}\n\n`;
      doc += `**Type:** ${rule.type.toUpperCase()}\n\n`;
      
      if (rule.type === 'decision') {
        doc += `**Condition:** ${formatConditionToDoc(rule.condition)}\n\n`;
        
        if (rule.trueBranch.length > 0) {
          doc += `**True Branch Actions:**\n`;
          rule.trueBranch.forEach(action => {
            doc += `- ${formatActionToDoc(action)}\n`;
          });
          doc += '\n';
        }
        
        if (rule.falseBranch.length > 0) {
          doc += `**False Branch Actions:**\n`;
          rule.falseBranch.forEach(action => {
            doc += `- ${formatActionToDoc(action)}\n`;
          });
          doc += '\n';
        }
      } else if (rule.type === 'evaluate') {
        doc += `**Subject:** ${rule.subject}\n\n`;
        doc += `**Cases:**\n`;
        rule.cases.forEach(caseItem => {
          doc += `\n### WHEN ${caseItem.condition}\n`;
          caseItem.actions.forEach(action => {
            doc += `- ${formatActionToDoc(action)}\n`;
          });
        });
        doc += '\n';
      }
      
      doc += '---\n\n';
    });
    
    return doc;
  };
  
  const formatConditionToDoc = (condition) => {
    if (!condition) return 'Always true';
    
    switch (condition.type) {
      case 'comparison':
        return `${condition.field} ${condition.operator} ${condition.value}`;
      case 'compound':
        return condition.conditions
          .map(c => formatConditionToDoc(c))
          .join(` ${condition.operator} `);
      case 'function':
        return `${condition.function}(${condition.argument})`;
      case 'boolean':
        return `${condition.field} is true`;
      default:
        return 'Unknown condition';
    }
  };
  
  const formatActionToDoc = (action) => {
    switch (action.type) {
      case 'assignment':
        return `Set ${action.target} to ${action.source}`;
      case 'computation':
        return `Calculate ${action.target} = ${action.expression}`;
      case 'perform':
        return `Execute procedure ${action.procedure}`;
      case 'display':
        return `Display message: "${action.message}"`;
      default:
        return action.statement || 'Unknown action';
    }
  };
  
  const generateJsonExport = (rules) => {
    return JSON.stringify({
      metadata: {
        exportDate: new Date().toISOString(),
        version: '1.0.0',
        rulesCount: rules.length
      },
      rules: rules,
      flowElements: flowElements
    }, null, 2);
  };
  
  const getExportContent = () => {
    switch (exportFormat) {
      case 'cobol':
        return generateCobolCode(rules);
      case 'procedure':
        return generateProcedureDivision(rules);
      case 'documentation':
        return generateDocumentation(rules);
      case 'json':
        return generateJsonExport(rules);
      default:
        return '';
    }
  };
  
  const handleExport = () => {
    const content = getExportContent();
    const fileExtension = {
      'cobol': 'cob',
      'procedure': 'cob',
      'documentation': 'md',
      'json': 'json'
    }[exportFormat];
    
    const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
    saveAs(blob, `business-rules-export.${fileExtension}`);
    message.success('File exported successfully');
  };
  
  const handleCopy = () => {
    const content = getExportContent();
    navigator.clipboard.writeText(content);
    message.success('Copied to clipboard');
  };
  
  return (
    <Card
      title="Export Business Rules"
      className="cobol-exporter"
      extra={
        <Space>
          <Select
            value={exportFormat}
            onChange={setExportFormat}
            style={{ width: 200 }}
          >
            <Option value="cobol">COBOL Snippets</Option>
            <Option value="procedure">Full Procedure Division</Option>
            <Option value="documentation">Documentation (Markdown)</Option>
            <Option value="json">JSON Format</Option>
          </Select>
          {exportFormat === 'cobol' || exportFormat === 'procedure' ? (
            <Select
              value={indentSize}
              onChange={setIndentSize}
              style={{ width: 120 }}
            >
              <Option value={2}>2 spaces</Option>
              <Option value={4}>4 spaces</Option>
              <Option value={6}>6 spaces</Option>
              <Option value={8}>8 spaces</Option>
            </Select>
          ) : null}
        </Space>
      }
    >
      {rules.length === 0 ? (
        <div style={{ textAlign: 'center', padding: '40px 0' }}>
          <Text type="secondary">No rules to export. Extract rules from COBOL code first.</Text>
        </div>
      ) : (
        <>
          <div style={{ marginBottom: 16 }}>
            <Space>
              <Button
                type="primary"
                icon={<DownloadOutlined />}
                onClick={handleExport}
              >
                Export File
              </Button>
              <Button
                icon={<CopyOutlined />}
                onClick={handleCopy}
              >
                Copy to Clipboard
              </Button>
            </Space>
          </div>
          
          <Divider />
          
          <div style={{ marginBottom: 16 }}>
            <Title level={5}>Preview</Title>
            <Paragraph type="secondary">
              {exportFormat === 'cobol' && 'COBOL code snippets for each business rule'}
              {exportFormat === 'procedure' && 'Complete PROCEDURE DIVISION with all rules'}
              {exportFormat === 'documentation' && 'Human-readable documentation in Markdown format'}
              {exportFormat === 'json' && 'Structured JSON format for rule interchange'}
            </Paragraph>
          </div>
          
          <CodeMirror
            value={getExportContent()}
            height="400px"
            theme="light"
            editable={false}
            extensions={exportFormat === 'json' ? [javascript()] : []}
          />
          
          <Divider />
          
          <div>
            <Title level={5}>Export Summary</Title>
            <Space direction="vertical">
              <Text>Total Rules: {rules.length}</Text>
              <Text>Decision Rules: {rules.filter(r => r.type === 'decision').length}</Text>
              <Text>Evaluate Rules: {rules.filter(r => r.type === 'evaluate').length}</Text>
              <Text>Format: {exportFormat.toUpperCase()}</Text>
            </Space>
          </div>
        </>
      )}
    </Card>
  );
};

export default CobolExporter;