const diff = require('diff');

class PatchGenerator {
    constructor() {
        this.patchTemplates = {
            'boundary-check': this.generateBoundaryCheck,
            'null-check': this.generateNullCheck,
            'overflow-protection': this.generateOverflowProtection,
            'division-guard': this.generateDivisionGuard,
            'file-error-handling': this.generateFileErrorHandling,
            'loop-termination': this.generateLoopTermination
        };
    }

    generatePatch(timeline, issueStep, patchType) {
        const step = timeline.steps[issueStep];
        if (!step) {
            throw new Error(`Step ${issueStep} not found`);
        }

        const generator = this.patchTemplates[patchType];
        if (!generator) {
            throw new Error(`Unknown patch type: ${patchType}`);
        }

        const patch = generator.call(this, step, timeline);
        
        return {
            patchType,
            targetParagraph: step.paragraph,
            targetSection: step.section,
            issueStep: issueStep,
            patch: patch,
            explanation: this.explainPatch(patchType, step),
            testCases: this.generateTestCases(patchType, step),
            impact: this.assessImpact(patch, timeline)
        };
    }

    generateBoundaryCheck(step, timeline) {
        const paragraph = step.paragraph;
        const variables = this.findNumericVariables(step);
        
        let patch = `       * Boundary check patch for ${paragraph}\n`;
        patch += `       * Generated by Time-Travel Debugger\n`;
        patch += `       * Issue detected at step ${step.index}\n\n`;

        variables.forEach(varInfo => {
            const varName = varInfo.name;
            const picture = varInfo.picture || '9(9)';
            const maxValue = this.getMaxValueForPicture(picture);

            patch += `       * Check ${varName} boundaries\n`;
            patch += `           IF ${varName} > ${maxValue}\n`;
            patch += `               DISPLAY "ERROR: ${varName} exceeds maximum value"\n`;
            patch += `               MOVE ${maxValue} TO ${varName}\n`;
            patch += `               MOVE "Y" TO WS-ERROR-FLAG\n`;
            patch += `           END-IF.\n\n`;

            patch += `           IF ${varName} < 0\n`;
            patch += `               DISPLAY "ERROR: ${varName} is negative"\n`;
            patch += `               MOVE 0 TO ${varName}\n`;
            patch += `               MOVE "Y" TO WS-ERROR-FLAG\n`;
            patch += `           END-IF.\n\n`;
        });

        return patch;
    }

    generateNullCheck(step, timeline) {
        const paragraph = step.paragraph;
        const variables = this.findAlphanumericVariables(step);
        
        let patch = `       * Null check patch for ${paragraph}\n`;
        patch += `       * Generated by Time-Travel Debugger\n\n`;

        variables.forEach(varInfo => {
            const varName = varInfo.name;

            patch += `       * Check ${varName} for null/spaces\n`;
            patch += `           IF ${varName} = SPACES OR ${varName} = LOW-VALUES\n`;
            patch += `               DISPLAY "WARNING: ${varName} is empty"\n`;
            patch += `               MOVE "DEFAULT" TO ${varName}\n`;
            patch += `           END-IF.\n\n`;
        });

        return patch;
    }

    generateOverflowProtection(step, timeline) {
        const paragraph = step.paragraph;
        const operation = step.operation || 'COMPUTE';
        
        let patch = `       * Overflow protection patch for ${paragraph}\n`;
        patch += `       * Generated by Time-Travel Debugger\n\n`;

        if (operation.includes('MULTIPLY') || operation.includes('COMPUTE')) {
            patch += `       * Add ON SIZE ERROR clause\n`;
            patch += `           ${operation}\n`;
            patch += `               ON SIZE ERROR\n`;
            patch += `                   DISPLAY "OVERFLOW ERROR IN ${paragraph}"\n`;
            patch += `                   MOVE "Y" TO WS-OVERFLOW-FLAG\n`;
            patch += `                   PERFORM ERROR-ROUTINE\n`;
            patch += `           END-${operation.split(' ')[0]}.\n\n`;
        }

        // Add working storage for overflow detection
        patch += `       * Add to WORKING-STORAGE SECTION:\n`;
        patch += `       01  WS-OVERFLOW-FLAG        PIC X VALUE "N".\n`;
        patch += `       01  WS-MAX-COMPUTE-VALUE    PIC 9(15) VALUE 999999999999999.\n\n`;

        return patch;
    }

    generateDivisionGuard(step, timeline) {
        const paragraph = step.paragraph;
        const divisorVar = this.findDivisorVariable(step);
        
        let patch = `       * Division guard patch for ${paragraph}\n`;
        patch += `       * Generated by Time-Travel Debugger\n\n`;

        if (divisorVar) {
            patch += `       * Check divisor before division\n`;
            patch += `           IF ${divisorVar} = 0\n`;
            patch += `               DISPLAY "ERROR: Division by zero attempted"\n`;
            patch += `               MOVE 1 TO ${divisorVar}\n`;
            patch += `               MOVE "Y" TO WS-DIVISION-ERROR\n`;
            patch += `           ELSE\n`;
            patch += `               DIVIDE ... BY ${divisorVar} ...\n`;
            patch += `           END-IF.\n\n`;
        }

        // Alternative using ON SIZE ERROR
        patch += `       * Alternative: Use ON SIZE ERROR\n`;
        patch += `           DIVIDE ... BY ${divisorVar || 'divisor'}\n`;
        patch += `               GIVING result\n`;
        patch += `               ON SIZE ERROR\n`;
        patch += `                   DISPLAY "DIVISION ERROR"\n`;
        patch += `                   MOVE ZERO TO result\n`;
        patch += `           END-DIVIDE.\n\n`;

        return patch;
    }

    generateFileErrorHandling(step, timeline) {
        const paragraph = step.paragraph;
        const fileOperation = step.operation || 'READ';
        
        let patch = `       * File error handling patch for ${paragraph}\n`;
        patch += `       * Generated by Time-Travel Debugger\n\n`;

        patch += `       * Add file status checking\n`;
        patch += `           ${fileOperation} file-name\n`;
        patch += `               AT END\n`;
        patch += `                   MOVE "Y" TO WS-EOF-FLAG\n`;
        patch += `               NOT AT END\n`;
        patch += `                   PERFORM PROCESS-RECORD\n`;
        patch += `           END-${fileOperation}.\n\n`;

        patch += `       * Check file status\n`;
        patch += `           IF WS-FILE-STATUS NOT = "00" AND "10"\n`;
        patch += `               DISPLAY "FILE ERROR: " WS-FILE-STATUS\n`;
        patch += `               PERFORM FILE-ERROR-ROUTINE\n`;
        patch += `           END-IF.\n\n`;

        patch += `       * Add to WORKING-STORAGE SECTION:\n`;
        patch += `       01  WS-FILE-STATUS          PIC XX.\n`;
        patch += `       01  WS-EOF-FLAG             PIC X VALUE "N".\n`;
        patch += `           88  END-OF-FILE         VALUE "Y".\n\n`;

        return patch;
    }

    generateLoopTermination(step, timeline) {
        const paragraph = step.paragraph;
        const loopCount = this.countLoopIterations(step, timeline);
        
        let patch = `       * Loop termination patch for ${paragraph}\n`;
        patch += `       * Generated by Time-Travel Debugger\n`;
        patch += `       * Loop executed ${loopCount} times\n\n`;

        patch += `       * Add loop counter and limit\n`;
        patch += `       01  WS-LOOP-COUNTER         PIC 9(6) VALUE ZERO.\n`;
        patch += `       01  WS-MAX-ITERATIONS       PIC 9(6) VALUE 10000.\n\n`;

        patch += `       * In ${paragraph}:\n`;
        patch += `           ADD 1 TO WS-LOOP-COUNTER.\n\n`;

        patch += `           IF WS-LOOP-COUNTER > WS-MAX-ITERATIONS\n`;
        patch += `               DISPLAY "ERROR: Loop limit exceeded in ${paragraph}"\n`;
        patch += `               MOVE "Y" TO WS-LOOP-ERROR\n`;
        patch += `               EXIT PARAGRAPH\n`;
        patch += `           END-IF.\n\n`;

        patch += `       * Reset counter when appropriate\n`;
        patch += `           MOVE ZERO TO WS-LOOP-COUNTER.\n\n`;

        return patch;
    }

    findNumericVariables(step) {
        const variables = [];
        for (const [name, info] of Object.entries(step.variables)) {
            if (info.type === 'NUMERIC' || info.type === 'DECIMAL') {
                variables.push({ name, ...info });
            }
        }
        return variables;
    }

    findAlphanumericVariables(step) {
        const variables = [];
        for (const [name, info] of Object.entries(step.variables)) {
            if (info.type === 'ALPHANUMERIC') {
                variables.push({ name, ...info });
            }
        }
        return variables;
    }

    findDivisorVariable(step) {
        // Look for variable that might be a divisor
        for (const [name, info] of Object.entries(step.variables)) {
            if ((name.includes('DIVISOR') || name.includes('DIV')) && 
                (info.value === 0 || info.value === '0')) {
                return name;
            }
        }
        return null;
    }

    countLoopIterations(step, timeline) {
        return timeline.steps.filter(s => s.paragraph === step.paragraph).length;
    }

    getMaxValueForPicture(picture) {
        const match = picture.match(/9\((\d+)\)/);
        if (match) {
            const digits = parseInt(match[1]);
            return Math.pow(10, digits) - 1;
        }
        return 999999999;
    }

    explainPatch(patchType, step) {
        const explanations = {
            'boundary-check': `This patch adds boundary checking to prevent numeric overflow or underflow in ${step.paragraph}. It ensures all numeric variables stay within their defined PICTURE clause limits.`,
            
            'null-check': `This patch adds null/empty value checking for alphanumeric fields in ${step.paragraph}. It prevents processing of empty values that could cause errors.`,
            
            'overflow-protection': `This patch adds ON SIZE ERROR handling to arithmetic operations in ${step.paragraph}. It gracefully handles cases where calculations exceed field capacity.`,
            
            'division-guard': `This patch prevents division by zero errors in ${step.paragraph} by checking divisor values before performing division operations.`,
            
            'file-error-handling': `This patch adds comprehensive file status checking for I/O operations in ${step.paragraph}. It handles various file error conditions gracefully.`,
            
            'loop-termination': `This patch adds a loop counter to prevent infinite loops in ${step.paragraph}. It limits iterations and provides an escape mechanism.`
        };

        return explanations[patchType] || 'Generic patch to handle edge case';
    }

    generateTestCases(patchType, step) {
        const testCases = [];

        switch (patchType) {
            case 'boundary-check':
                testCases.push({
                    description: 'Test with maximum allowed value',
                    input: { [Object.keys(step.variables)[0]]: '999999999' },
                    expected: 'Value should be capped at maximum'
                });
                testCases.push({
                    description: 'Test with negative value',
                    input: { [Object.keys(step.variables)[0]]: '-100' },
                    expected: 'Value should be set to 0'
                });
                break;

            case 'null-check':
                testCases.push({
                    description: 'Test with spaces',
                    input: { [Object.keys(step.variables)[0]]: '     ' },
                    expected: 'Should set default value'
                });
                break;

            case 'division-guard':
                testCases.push({
                    description: 'Test with zero divisor',
                    input: { divisor: '0' },
                    expected: 'Should handle gracefully without abend'
                });
                break;
        }

        return testCases;
    }

    assessImpact(patch, timeline) {
        const impact = {
            affectedParagraphs: new Set(),
            performanceImpact: 'LOW',
            riskLevel: 'MEDIUM',
            estimatedLines: patch.split('\n').length,
            requiresRecompilation: true
        };

        // Find all paragraphs that might be affected
        const patchLines = patch.split('\n');
        patchLines.forEach(line => {
            if (line.includes('PERFORM')) {
                const match = line.match(/PERFORM\s+(\S+)/);
                if (match) {
                    impact.affectedParagraphs.add(match[1]);
                }
            }
        });

        // Assess performance impact
        if (patch.includes('LOOP') || patch.includes('COUNTER')) {
            impact.performanceImpact = 'MEDIUM';
        }

        // Assess risk level
        if (patch.includes('DIVISION') || patch.includes('FILE')) {
            impact.riskLevel = 'HIGH';
        }

        return impact;
    }

    generateCompletePatch(timeline, issues) {
        let completePatch = `      *****************************************************************\n`;
        completePatch += `      * COBOL Edge Case Patches\n`;
        completePatch += `      * Generated by Time-Travel Debugger\n`;
        completePatch += `      * Date: ${new Date().toISOString()}\n`;
        completePatch += `      * Program: ${timeline.programName}\n`;
        completePatch += `      * Trace ID: ${timeline.traceId}\n`;
        completePatch += `      *****************************************************************\n\n`;

        // Group patches by section
        const patchesBySection = {};

        issues.forEach(issue => {
            const section = issue.section || 'PROCEDURE';
            if (!patchesBySection[section]) {
                patchesBySection[section] = [];
            }
            patchesBySection[section].push(issue);
        });

        // Generate patches for each section
        for (const [section, sectionIssues] of Object.entries(patchesBySection)) {
            completePatch += `      * Patches for ${section} DIVISION\n`;
            completePatch += `      *---------------------------------\n\n`;

            sectionIssues.forEach(issue => {
                const patch = this.generatePatch(timeline, issue.stepIndex, issue.recommendedPatch);
                completePatch += patch.patch + '\n\n';
            });
        }

        return completePatch;
    }

    // Generate COBOL unit test for the patch
    generateUnitTest(patchType, step) {
        let test = `       IDENTIFICATION DIVISION.\n`;
        test += `       PROGRAM-ID. TEST-${step.paragraph}.\n\n`;
        
        test += `       DATA DIVISION.\n`;
        test += `       WORKING-STORAGE SECTION.\n`;
        test += `       01  WS-TEST-RESULT          PIC X VALUE "P".\n`;
        test += `           88  TEST-PASSED         VALUE "P".\n`;
        test += `           88  TEST-FAILED         VALUE "F".\n\n`;

        test += `       PROCEDURE DIVISION.\n`;
        test += `       MAIN-PROCEDURE.\n`;
        
        const testCases = this.generateTestCases(patchType, step);
        testCases.forEach((testCase, index) => {
            test += `           PERFORM TEST-CASE-${index + 1}.\n`;
        });
        
        test += `           IF TEST-PASSED\n`;
        test += `               DISPLAY "ALL TESTS PASSED"\n`;
        test += `           ELSE\n`;
        test += `               DISPLAY "TESTS FAILED"\n`;
        test += `           END-IF.\n`;
        test += `           STOP RUN.\n\n`;

        return test;
    }
}

module.exports = PatchGenerator;